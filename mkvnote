#!/bin/bash

# The shebang above specifies that this script should be run with the Bash shell.
# It tells the system that the script should be interpreted using Bash.

# Declaration of an array named MKV_TAG_SET_NMAAHC to hold tag names specific to the NMAAHC profile.
MKV_TAG_SET_NMAAHC=(
    "COLLECTION"             # (Same as above) The collection to which the video belongs.
    "TITLE"                  # (Same as above) The title of the video, likely matching the archive's system.
    "CATALOG_NUMBER"         # (Same as above) Unique identifier or catalog number for the video.
    "DESCRIPTION"            # (Same as above) Brief description of the video's content.
    "DATE_DIGITIZED"         # (Same as above) The date when the video was digitized.
    "ENCODER_SETTINGS"       # (Same as above) Details about the encoding process.
    "ENCODED_BY"             # (Same as above) Information about the entity or person who encoded the video.
    "ORIGINAL_MEDIA_TYPE"    # (Same as above) The original format of the media before digitization.
    "DATE_TAGGED"            # (Same as above) The date when these tags were applied or updated.
    "TERMS_OF_USE"           # (Same as above) Legal or usage terms associated with the video.
    "_PRE_TRANSFER_NOTES"    # Free text for capturing anything concerning the inspection and any physical conservation or preparation of the tape.
    "_TRANSFER_NOTES"        # Any technical notes related to the video or digitization process.
    "_ORIGINAL_FPS"          # (Same as above) The original frames per second for the film.
)

# Setting up color and style variables using `tput`.
# These variables define text appearance in the scriptâ€™s output (bold, color, etc.).
BOLD=$(tput bold)          # Sets text style to bold for emphasis.
RESET=$(tput sgr0)         # Resets text style to the default, removing any bold or color.
GB=$(tput setaf 38)        # Sets the text color to greenish-blue for regular output.
ERROR=$(tput setaf 1)      # Sets the text color to red for error messages.

# Definition of the `_usage` function to provide usage information for the script.
# *** LEFT UNCHANGED PER YOUR REQUEST ***
_usage(){
    cat <<EOF

    $(basename "${0}")

    This application will embed key:value pairs ("tags") into a Matroska file.
   
    Usage: $(basename "${0}") [-p|--profile <profile>] /path/to/file

    Tag keys are pre-defined in sets: JPC or NMAAHC

    JPC:
        "COLLECTION"
        "TITLE"
        "CATALOG_NUMBER"
        "DESCRIPTION"
        "DATE_DIGITIZED"
        "ENCODER_SETTINGS"
        "ENCODED_BY"
        "ORIGINAL_MEDIA_TYPE"
        "DATE_TAGGED"
        "TERMS_OF_USE"
        "_PRE_TRANSFER_NOTES"
        "_TRANSFER_NOTES"
        "_ORIGINAL_FPS"

    NMAAHC:
        "COLLECTION"
        "TITLE"
        "CATALOG_NUMBER"
        "DESCRIPTION"
        "DATE_DIGITIZED"
        "ENCODER_SETTINGS"
        "ENCODED_BY"
        "ORIGINAL_MEDIA_TYPE"
        "DATE_TAGGED"
        "TERMS_OF_USE"
        "_PRE_TRANSFER_NOTES"  
        "_TRANSFER_NOTES"
        "_ORIGINAL_FPS"
        "_TAGTAG"

    Tags beginning with an underscore are not part of the official set of Matroska tags as defined here:
    https://www.matroska.org/technical/tagging.html

    The script needs swiftdialog to run. It can be installed here:
    https://github.com/swiftDialog/swiftDialog/releases

    Calling the script will bring up a dialog window in which to enter values for the tag set you have chosen.

    The script can also be run in batch mode by feeding it a .csv

    filename	director    rating
    test.mkv	dave	    pg
    test2.mkv	blake	    no
    test3.mkv	immy	    g

    The filename should be the full path of the file.

    Usage: $(basename "${0}") mycsv.csv

    To produce a csv output from a list of mkv files:
    $(basename "${0}") -c file1.mkv file2.mkv file3.mkv > my.csv

    The output can then be edited to write back into the source files with "$(basename "${0}") my.csv"

    Tag definitions for JPC:
    Tag                     Example
    COLLECTION              The name of the collection that the content or object is from ; ex. Johnson Publishing Company Archive / Pearl Bowser Collection
    TITLE                   Should be the same as ASpace ; ex. Ebony/Jet Showcase #1001 / A Pinch of Soul
    CATALOG_NUMBER          Often the file name ; ex. JPC_AV_12345 / 2012.79.2.54.1a
    DESCRIPTION             Please be brief! Ok to leave blank! ex. In the 1980s a young journalist moves to New York City / Broadcast of the 1978 American Black Achievement Awards
    DATE_DIGITIZED          yyyy-mm-dd ; ex. 2024-10-10
    ENCODER_SETTINGS        Source VTR: model name, serial number, video signal type (Composite, SDI, etc.), audio signal type (analog balanced, analog unbalanced, embedded, etc.) ;
                            TBC/Framesync: model name, serial number, video signal type, audio signal type ;
                            ADC: model name, serial number, video signal type, audio signal type (if audio is embedded  at this point simply say "embedded") ;
                            Capture Device: model name, serial number, data connection type (Thunderbolt/PCIe/SATA/etc) ;
                            Computer: model name, serial number, computer os version, capture software (including version), encoding software (ffmpeg version not required)
    ENCODED_BY              Entity, name, country ; ex. Smithsonian NMAAHC, James Smithson, US (use ISO 3166-1 alpha-2 codes)
    ORIGINAL_MEDIA_TYPE     Format (from PB Core), manufacturer, model ; ex. U-matic, Sony, KSP-30 (don't guess or estimate the manufacturer or model - the format is plenty sufficient if the others are ambiguous)
    DATE_TAGGED             yyyy-mm-dd, this is the date the mkv tags were embedded or updated ; ex. 2024-10-18
    TERMS_OF_USE            Not definitive, nor authoritative ; ex. Some or all of this video maybe subject to copyright or other intellectual property rights. Proper usage is the responsibility of the user.
    _PRE_TRANSFER_NOTES     Free text for capturing anything concerning the inspection and any physical conservation or preparation of the tape.
    _TRANSFER_NOTES         Any technical notes related to the video or digitization process.
    _ORIGINAL_FPS           For motion picture film, the frames per second at which the film was meant to be projected. most common - 16, 18, 24 ; ex. 24

EOF
exit
}

_check_dependencies(){
    DEPS_OK=YES
    while [ "${*}" != "" ] ; do
        DEPENDENCY="${1}"
        if [ ! $(which "${DEPENDENCY}") ] ; then
            echo "This script requires ${DEPENDENCY} to run but it is not installed"
            echo "If you are running ubuntu or debian you might be able to install ${DEPENDENCY} with the following command"
            echo "sudo apt-get install ${DEPENDENCY}"
            echo "If you are running mac you might be able to install ${DEPENDENCY} with the following command"
            echo "brew install ${DEPENDENCY}"
            DEPS_OK=NO
        fi
        shift
    done
    if [[ "${DEPS_OK}" = "NO" ]]; then
        echo "Unmet dependencies"
        echo "Exiting!"
        exit 1
    else
        return 0
    fi
}

_check_dependencies csvprintf xmlstarlet mkvpropedit mkvextract xml2csv

# Escape XML special characters in tag values (for writing)
_escape_xml() {
    echo "$1" | sed \
        -e 's/&/\&amp;/g' \
        -e 's/</\&lt;/g' \
        -e 's/>/\&gt;/g' \
        -e 's/"/\&quot;/g' \
        -e "s/'/\&apos;/g"
}

# Unescape XML entities back to original characters (for display)
_unescape_xml() {
    echo "$1" | sed \
        -e 's/\&amp;/\&/g' \
        -e 's/\&lt;/</g' \
        -e 's/\&gt;/>/g' \
        -e 's/\&quot;/"/g' \
        -e "s/\&apos;/'/g"
}

# Initialize variables to store the selected tag set (NMAAHC only now).
SELECTED_TAG_SET=("${MKV_TAG_SET_NMAAHC[@]}")

OPTIND=1
while getopts ":chp:" opt ; do
    case "${opt}" in
        p) : ;;                         
        c) MKV2CSV="Y" ;;               
        h) _usage ;;                    
        :) echo "Option -${OPTARG} requires an argument" ; _usage ;;
        *) echo "bad option -${OPTARG}" ; _usage ;;
    esac
done
shift "$((OPTIND-1))"

if [[ "${#}" -eq 0 ]]; then
    _usage
fi

INPUT_FILE="${1}"
EXTENSION="${INPUT_FILE##*.}"

_maketemp(){
    mktemp -q -t "$(basename "${0}")"
    if [ "${?}" -ne 0 ]; then
        echo "${0}: ${ERROR}Can't create temp file, exiting...${RESET}"
        exit 1
    fi
}

# ------------------------------
# CSV MODE
# ------------------------------
if [[ "${EXTENSION}" == "csv" ]] ; then
    CSV_XML="$(_maketemp).xml"
    csvprintf -X -f "${INPUT_FILE}" > "${CSV_XML}"
    ELEMENT_LIST="$(xmlstarlet sel -t -m "/csv/row[1]/*" -v "name()" -n "${CSV_XML}")"
    FILENAME_FOUND=0
    echo "Examining the csv: ${CSV_XML}."
    while read ELEMENT_VALUE ; do
        if [[ "${ELEMENT_VALUE//_}" == "filename" ]] ; then
            FILENAME_COLUMN_NAME="${ELEMENT_VALUE}"
            ELEMENT_VALUE="filename"
        fi
        echo "Found ${ELEMENT_VALUE}."
        ADDITIONAL_COLUMNS+="_${ELEMENT_VALUE}"
        if [[ "${ELEMENT_VALUE}" == "filename" ]] ; then
            FILENAME_FOUND=1
        fi
    done < <(echo "${ELEMENT_LIST}")

    if [[ "${FILENAME_FOUND}" = "0" ]] ; then
        echo "${BOLD}${ERROR}Error, $(basename "${INPUT_FILE}") does not contain a column called 'filename'. Exiting.${RESET}"
        exit
    fi

    MISSING_FILE=0
    REPEATED_FILENAMES="$(xmlstarlet sel -t -m "/csv/row/___filename" -v . -n  "${CSV_XML}" | sort | uniq -c | grep -v "^ *1 ")"
    if [[ -n "${REPEATED_FILENAMES}" ]] ; then
        echo "${BOLD}${ERROR}Error, ${INPUT_FILE} contains multiple iterations of the same filename.${RESET}"
        echo "${REPEATED_FILENAMES}"
        echo "${BOLD}${ERROR}Come back when it's fixed.${RESET}"
        exit 1
    fi
    while read FILE_IN_CSV ; do
        if [[ ! -f "${FILE_IN_CSV}" ]] ; then
            echo "${BOLD}${ERROR}Error, $(basename "${FILE_IN_CSV}") is referenced in the csv but not found.${RESET}"
            MISSING_FILE=1
            MISSING_FILE_LIST+="${FILE_IN_CSV} "
        fi
    done < <(xmlstarlet sel -t -m "/csv/row/${FILENAME_COLUMN_NAME}" -v . -n "${CSV_XML}")
    if [[ -z "${FILENAME_COLUMN_NAME}" ]] ; then
        FILENAME_COLUMN_NAME="filename"
    fi
    if [[ "${MISSING_FILE}" != "0" ]] ; then
        echo "${BOLD}${ERROR}Error, Some files in the csv, such as ${MISSING_FILE_LIST}, are not found. Exiting.${RESET}"
        exit
    else
        echo "${BOLD}Nice. All files from the csv are found. Let's tag.${RESET}"
    fi

    while read FILE_IN_CSV ; do
        XML_DRAFT="$(_maketemp).xml"
        mkvextract tags "${FILE_IN_CSV}" > "${XML_DRAFT}"
        EXISTING_TAGS="$(xmlstarlet sel -t -m '/Tags/Tag[not(Targets) or count(Targets/*)=0]/Simple/Name' -v . -n "${XML_DRAFT}" | awk '!seen[$0]++')"
        echo "${BOLD}Tagging ${FILE_IN_CSV} with: ${RESET}"
        echo "---------------------|---------------------"

        while read TAG_NAME ; do
            TAG_VALUE="$(xmlstarlet sel -t -m "/csv/row[${FILENAME_COLUMN_NAME}='${FILE_IN_CSV}']/${TAG_NAME}" -v "." -n "${CSV_XML}")"
            if [[ "${TAG_NAME//_}" == "filename" ]] ; then
                TAG_NAME="filename"
            fi

            if ! xmlstarlet sel -t -m '/Tags/Tag[not(Targets) or count(Targets/*)=0]' -v '.' -n "${XML_DRAFT}" | grep -q . ; then
              xmlstarlet ed -P -L \
                -s '/Tags' -t elem -n 'Tag' \
                -s '/Tags/Tag[last()]' -t elem -n 'Targets' \
                "${XML_DRAFT}"
              echo "Added a new <Tag> with empty <Targets> with ${FILE_IN_CSV}."
            fi

            if [[ -n "${TAG_VALUE// /}" && "${TAG_NAME//_}" != "filename" ]] ; then
                if echo "${EXISTING_TAGS}" | grep -Fxq "${TAG_NAME}"; then
                    xml ed --omit-decl -P --inplace \
                        --update "(/Tags/Tag[Simple/Name='${TAG_NAME}'])[last()]/Simple[Name='${TAG_NAME}']/String" -v "$(_escape_xml "${TAG_VALUE}")" \
                        "${XML_DRAFT}"
                else
                    xml ed --omit-decl --inplace \
                        --subnode "/Tags/Tag[not(Targets) or count(Targets/*)=0]" --type elem -n "Simple" \
                        --subnode "/Tags/Tag[not(Targets) or count(Targets/*)=0]/Simple[not(Name)]" --type elem -n "Name" -v "${TAG_NAME}" \
                        --subnode "/Tags/Tag[not(Targets) or count(Targets/*)=0]/Simple[not(String)]" --type elem -n "String" -v "$(_escape_xml "${TAG_VALUE}")" \
                        "${XML_DRAFT}"
                fi
            fi
            printf "%-22s" "$TAG_NAME"
            echo "$TAG_VALUE" | sed '1n; s/^/                      /'

        done < <(xmlstarlet sel -t -m "/csv/row[${FILENAME_COLUMN_NAME}='${FILE_IN_CSV}']/*[normalize-space(.) != '']" -v "name()" -n "${CSV_XML}")

        echo
        mkvpropedit --tags "all:${XML_DRAFT}" "${FILE_IN_CSV}"

    done < <(xmlstarlet sel -t -m "/csv/row/${FILENAME_COLUMN_NAME}" -v . -n "${CSV_XML}")

    exit
fi

if [[ "${MKV2CSV}" == "Y" ]] ; then
    INPUT_FILES=("$@")
    while [[ "${@}" != "" ]] ; do
        INPUT_FILE="${1}"
        shift
        EXTRACTED_TAGS="$(_maketemp).xml"
        XML_DRAFT="$(_maketemp).xml"
        mkvextract tags "${INPUT_FILE}" > "${EXTRACTED_TAGS}"
        TAGS_FOUND+="$(xmlstarlet sel -t -m "/Tags/Tag[Targets='' or not(Targets) or (Targets/TargetTypeValue='50' and not(Targets/TrackUID))]/Simple" -v "Name" -n "${EXTRACTED_TAGS}")"$'\n'
    done
    UNIQUE_TAGS="$(awk 'NF && !seen[$0]++' <<< "$TAGS_FOUND")"

    CSV_XML="$(_maketemp).xml"
    echo "<csv/>" > "${CSV_XML}"
    for INPUT_FILE in "${INPUT_FILES[@]}"; do
        XML_ED_INSTRUCTIONS=()
        EXTRACTED_TAGS="$(_maketemp).xml"
        mkvextract tags "${INPUT_FILE}" > "${EXTRACTED_TAGS}"
        while read UNIQUE_TAG ; do
            UNIQUE_TAG_VALUE="$(xmlstarlet sel -t -m "/Tags/Tag[Targets='' or not(Targets) or (Targets/TargetTypeValue='50' and not(Targets/TrackUID))]/Simple[Name='${UNIQUE_TAG}']" -v "String" -n "${EXTRACTED_TAGS}")"
            XML_ED_INSTRUCTIONS+=(--subnode "/csv/row[not(${UNIQUE_TAG})]" --type elem -n "${UNIQUE_TAG}" -v "${UNIQUE_TAG_VALUE}")
        done <<< "${UNIQUE_TAGS}"

        xml ed --omit-decl --inplace \
            --subnode "/csv" --type elem -n "row" \
            --subnode "/csv/row[not(filename)]" --type elem -n "filename" -v "${INPUT_FILE}" "${XML_ED_INSTRUCTIONS[@]}" "${CSV_XML}"
    done
    CSV_HEADER=$(xmlstarlet sel -t -m "/csv/row[1]/*" -v "name()" -o "," "${CSV_XML}" | sed 's/,$//')
    echo "${CSV_HEADER}"
    xml2csv "${CSV_XML}"
    exit
fi

# ------------------------------
# GUI MODE
# ------------------------------
EXISTING_TAGS="$(_maketemp).txt"
EXTRACTED_TAGS="$(_maketemp).txt"
XML_DRAFT="$(_maketemp).xml"

mkvextract tags "${INPUT_FILE}" > "${EXTRACTED_TAGS}"
xmlstarlet sel -t -m "/Tags/Tag[Targets='' or not(Targets) or (Targets/TargetTypeValue='50' and not(Targets/TrackUID))]/Simple" -v "Name" -n "${EXTRACTED_TAGS}" >> "${EXISTING_TAGS}"

while read EXISTING_KEY ; do
    DIALOG_LIST+="${EXISTING_KEY} "
    if [[ ! ${SELECTED_TAG_SET[*]} =~ "\"${EXISTING_KEY}\"" ]] ; then
        TEMP_DIALOG_VALUE="$(_maketemp).txt"
        xmlstarlet sel -t -m "/Tags/Tag[Targets='' or not(Targets) or (Targets/TargetTypeValue='50' and not(Targets/TrackUID))]/Simple[Name='${EXISTING_KEY}']" -v "String" "${EXTRACTED_TAGS}" \
            | _unescape_xml > "${TEMP_DIALOG_VALUE}"
        LINE_COUNT="$(awk 'BEGIN{count=0} {count++} END{print count}' < "${TEMP_DIALOG_VALUE}")"
        if [[ ! " ${SELECTED_TAG_SET[*]} " =~ [[:space:]]${EXISTING_KEY}[[:space:]] ]] ; then
            KEY_LABEL="${EXISTING_KEY}*"
        else
            KEY_LABEL="${EXISTING_KEY}"
        fi
        LIST_OF_KEYS+=("${EXISTING_KEY}")
        if [[ "${LINE_COUNT}" -lt "2" ]] ; then
            DIALOG_LIST_EMBEDDED+="
                    <hbox>
                        <hbox width-request=\"200\">
                            <text xalign=\"0\">
                                <label>${KEY_LABEL}</label>
                            </text>
                        </hbox>
                        <hbox width-request=\"800\">
                            <entry width=\"700\">
                                <variable>${EXISTING_KEY}</variable>
                                <input file>${TEMP_DIALOG_VALUE}</input>
                                <action signal=\"show\">refresh:${EXISTING_KEY}</action>
                            </entry>
                        </hbox>
                    </hbox>"
        else
            DIALOG_LIST_EMBEDDED+="
                <hbox>
                    <hbox width-request=\"200\">
                        <text xalign=\"0\">
                            <label>${KEY_LABEL}</label>
                        </text>
                    </hbox>
                    <hbox width-request=\"800\">
                        <edit width=\"700\" wrap-mode=\"1\">
                            <variable>${EXISTING_KEY}</variable>
                            <input file>${TEMP_DIALOG_VALUE}</input>
                            <action signal=\"show\">refresh:${EXISTING_KEY}</action>
                        </edit>
                    </hbox>
                </hbox>"
        fi
    fi
done < "${EXISTING_TAGS}"

for PROFILE_TAG in "${SELECTED_TAG_SET[@]}" ; do
    PROFILE_KEY="${PROFILE_TAG%%=*}"
    if [[ ! " ${DIALOG_LIST[*]} " =~ [[:space:]]${PROFILE_TAG}[[:space:]] ]] ; then
        LIST_OF_KEYS+=("${PROFILE_TAG}")
        if [[ "${PROFILE_KEY}" == "DESCRIPTION" || "${PROFILE_KEY}" == "ENCODER_SETTINGS" ]]; then
            DIALOG_LIST_PROFILE+="
                <hbox>
                    <hbox width-request=\"200\">
                        <text xalign=\"0\">
                            <label>${PROFILE_KEY}</label>
                        </text>
                    </hbox>
                    <hbox width-request=\"800\">
                        <edit width=\"700\" wrap-mode=\"1\">
                            <variable>${PROFILE_KEY}</variable>
                        </edit>
                    </hbox>
                </hbox>"
        else
            DIALOG_LIST_PROFILE+="
                <hbox>
                    <hbox width-request=\"200\">
                        <text xalign=\"0\">
                            <label>${PROFILE_KEY}</label>
                        </text>
                    </hbox>
                    <hbox width-request=\"800\">
                        <entry width=\"700\">
                            <variable>${PROFILE_KEY}</variable>
                        </entry>
                    </hbox>
                </hbox>"
        fi
    fi 
done

echo '
style "bgWhite" { bg[NORMAL] = "#FFFFFF" }
style "fgWhite" { fg[NORMAL] = "white"  font_name = "Mono 16"}
style "fgBlack" { fg[NORMAL] = "black" }
style "bgMain" { bg[NORMAL] = "#671E75" }
style "bgRed" { bg[NORMAL] = "red" }
style "fgRed" { fg[NORMAL] = "red" }
style "bgGreen" { bg[NORMAL] = "#BB55BB" }
style "fgGreen" { fg[NORMAL] = "green" }
style "bgBlue" { bg[NORMAL] = "#0000FF" }
style "fgBlue" { fg[NORMAL] = "#0000FF" }
style "custom-font" { font_name = "Sans 64" }

widget "mkvnotemain" style "bgMain"

widget_class "*GtkLabel" style "fgWhite"
widget_class "*.GtkLabel" style "fgWhite"

' > /tmp/gtkrc_mono
export GTK2_RC_FILES=/tmp/gtkrc_mono

DIALOG_FORM="$(_maketemp).xml"

cat << EOF > "${DIALOG_FORM}"
<window title="Welcome to mkvnote!" default-width="1100" name="mkvnotemain">
    <vbox>
        <text xalign="0" width-request="1000">
            <label>These tags semantically are intended to describe the file as a whole and not intended to specifically refer to a particular track or attachment or other sort of piece of the file. Empty tags will be ignored. If you edit exisitng tags here they will be overwritten when saved.</label>
        </text>
        <vbox scrollable="true" height="600" space-expand="true" space-fill="true">
            <text xalign="0" width-request="1000">
                <label>Metadata tags already embedded. (* for part of the NMAAHC profile)</label>
            </text>
            ${DIALOG_LIST_EMBEDDED}
            <text xalign="0" width-request="1000">
                <label>Yet unused metadata tags from the NMAAHC profile.</label>
            </text>
            ${DIALOG_LIST_PROFILE}
        </vbox>
        <hbox space-expand="false" space-fill="false">
            <button>
                <label>Settings</label>
                <input file stock="gtk-index"></input>
                <variable export="false">settings_button</variable>
            </button>
            <hbox space-expand="true" space-fill="true">
                <text>
                    <label>""</label>
                </text>
            </hbox>
            <button>
                <label>Tag-On!</label>
                <input file stock="gtk-media-record"></input>
                <variable export="false">record_button</variable>
            </button>
            <button cancel>
            </button>
        </hbox>
    </vbox>
</window>
EOF

DIALOG_RESULT="$(export MAIN_DIALOG="$(cat "${DIALOG_FORM}")" ; gtkdialog --center --program MAIN_DIALOG)"
EXIT_STATUS="$(echo "${DIALOG_RESULT}" | grep "^EXIT=" | cut -d= -f2- | sed 's


    # A fun message to indicate completion
    cowsay "Cool. Done. Enjoy. Tag-on. ${INPUT_FILE}.${RESET}"
fi
